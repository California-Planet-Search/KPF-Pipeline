

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>kpfpipe.pipelines.kpf_parse_ast &mdash; KPFPipeline 0.0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> KPFPipeline
          

          
          </a>

          
            
            
              <div class="version">
                0.0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../intro/getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../repository/start.html">Repository</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/api.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../primitives/primitives.html">Implemented Primitives</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">KPFPipeline</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>kpfpipe.pipelines.kpf_parse_ast</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for kpfpipe.pipelines.kpf_parse_ast</h1><div class="highlight"><pre>
<span></span><span class="c1"># kpf_parse_ast.py</span>

<span class="kn">from</span> <span class="nn">ast</span> <span class="kn">import</span> <span class="n">NodeVisitor</span><span class="p">,</span> <span class="n">iter_fields</span>
<span class="kn">import</span> <span class="nn">_ast</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">Queue</span>
<span class="c1"># from kpfpipe.pipelines.FauxLevel0Primitives import read_data, Normalize, NoiseReduce, Spectrum1D</span>

<span class="kn">from</span> <span class="nn">keckdrpframework.models.action</span> <span class="kn">import</span> <span class="n">Action</span>
<span class="kn">from</span> <span class="nn">keckdrpframework.models.arguments</span> <span class="kn">import</span> <span class="n">Arguments</span>
<span class="kn">from</span> <span class="nn">keckdrpframework.models.processing_context</span> <span class="kn">import</span> <span class="n">ProcessingContext</span>

<div class="viewcode-block" id="RecipeError"><a class="viewcode-back" href="../../../api/pipeline/parse_ast.html#kpfpipe.pipelines.kpf_parse_ast.RecipeError">[docs]</a><span class="k">class</span> <span class="nc">RecipeError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Special recipe exception &quot;&quot;&quot;</span></div>

<div class="viewcode-block" id="KpfPipelineNodeVisitor"><a class="viewcode-back" href="../../../api/pipeline/parse_ast.html#kpfpipe.pipelines.kpf_parse_ast.KpfPipelineNodeVisitor">[docs]</a><span class="k">class</span> <span class="nc">KpfPipelineNodeVisitor</span><span class="p">(</span><span class="n">NodeVisitor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Node visitor to convert KPF pipeline recipes expressed in python syntax</span>
<span class="sd">    into operations on the KPF Framework.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pipeline</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">NodeVisitor</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># instantiate the parameters dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_params</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># store and load stacks</span>
        <span class="c1"># (implemented as lists; use append() and pop())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_store</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="c1"># KPF framework items</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span> <span class="o">=</span> <span class="n">pipeline</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">context</span> <span class="o">=</span> <span class="n">context</span>
        <span class="c1"># local state flags</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">awaiting_call_return</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">returning_from_call</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_visited_states</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># value returned by primitive executed by framework</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">call_output</span> <span class="o">=</span> <span class="kc">None</span>
    
<div class="viewcode-block" id="KpfPipelineNodeVisitor.visit_Module"><a class="viewcode-back" href="../../../api/pipeline/parse_ast.html#kpfpipe.pipelines.kpf_parse_ast.KpfPipelineNodeVisitor.visit_Module">[docs]</a>    <span class="k">def</span> <span class="nf">visit_Module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Module node</span>
<span class="sd">        A Module node is always at the top of an AST tree returned</span>
<span class="sd">        by ast.parse(), and there is only one, so we initialize</span>
<span class="sd">        or reset things here, and clean up (releasing allocated</span>
<span class="sd">        memory) at the end.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reset_visited_states</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_started&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_completed&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_params</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># let storage get collected</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_started&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Module&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_params</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_started&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_completed&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">awaiting_call_return</span><span class="p">:</span>
                    <span class="k">return</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_params</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># let allocated memory get collected</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_completed&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="KpfPipelineNodeVisitor.visit_ImportFrom"><a class="viewcode-back" href="../../../api/pipeline/parse_ast.html#kpfpipe.pipelines.kpf_parse_ast.KpfPipelineNodeVisitor.visit_ImportFrom">[docs]</a>    <span class="k">def</span> <span class="nf">visit_ImportFrom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        import primitives and add them to the pipeline&#39;s event_table</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reset_visited_states</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_completed&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_completed&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">module</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">module</span>
            <span class="c1"># append the module path to the framework&#39;s primitive_path</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">primitive_path</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">primitive_path</span><span class="p">,</span> <span class="n">module</span><span class="p">])</span>
            <span class="n">loadQSizeBefore</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">loadQSizeBefore</span><span class="p">:</span>
                    <span class="c1"># import the named primitive</span>
                    <span class="c1"># This comes as a 2-element tuple from visit_alias</span>
                    <span class="c1">#</span>
                    <span class="c1"># just add the name to the event_table for now</span>
                    <span class="c1"># But we should ensure that the name exists in the module and is Callable</span>
                    <span class="n">tup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="c1"># create an event_table entry that returns control</span>
                    <span class="c1"># to the pipeline after running</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">event_table</span><span class="p">[</span><span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;Processing&quot;</span><span class="p">,</span> <span class="s2">&quot;resume_recipe&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Added </span><span class="si">{</span><span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> from </span><span class="si">{</span><span class="n">module</span><span class="si">}</span><span class="s2"> to event_table&quot;</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_completed&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="KpfPipelineNodeVisitor.visit_alias"><a class="viewcode-back" href="../../../api/pipeline/parse_ast.html#kpfpipe.pipelines.kpf_parse_ast.KpfPipelineNodeVisitor.visit_alias">[docs]</a>    <span class="k">def</span> <span class="nf">visit_alias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        alias node</span>
<span class="sd">        These only appear in import clauses</span>
<span class="sd">        Implement by putting name and asname on _load stack as tuple.</span>
<span class="sd">        ImportFrom handles the heavy lifting</span>
<span class="sd">        Note: asname is currently not supported and is ignored.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reset_visited_states</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_completed&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_completed&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">asname</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;alias: </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> as </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">asname</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_completed&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="KpfPipelineNodeVisitor.visit_Name"><a class="viewcode-back" href="../../../api/pipeline/parse_ast.html#kpfpipe.pipelines.kpf_parse_ast.KpfPipelineNodeVisitor.visit_Name">[docs]</a>    <span class="k">def</span> <span class="nf">visit_Name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implementation of Name node</span>
<span class="sd">        A Name can occur on either the left or right side of an assignment.</span>
<span class="sd">        If it&#39;s on the left side the context is Store, and the Name is the</span>
<span class="sd">        variable name into which to store a value.  We push that variable name</span>
<span class="sd">        on the _store stack.</span>
<span class="sd">        If the Name is on the right side, e.g. as part of an expression,</span>
<span class="sd">        we look up the name in our params dict, and push the corresponding</span>
<span class="sd">        value on the _load stack.  If the name is not found, None is pushed</span>
<span class="sd">        on the _load stack.</span>

<span class="sd">        WARNING: The same instance of a Name can appear as different nodes in a AST,</span>
<span class="sd">        so nothing should be stored in the node as a node-specific attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reset_visited_states</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Name: </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">_ast</span><span class="o">.</span><span class="n">Store</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Name is storing </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">ctx</span><span class="p">,</span> <span class="n">_ast</span><span class="o">.</span><span class="n">Load</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            if not hasattr(self._params, node.id):</span>
<span class="sd">                self.pipeline.logger.error(</span>
<span class="sd">                    f&quot;Name {node.id} on line {node.lineno} of recipe not defined.&quot;)</span>
<span class="sd">                raise RecipeError(</span>
<span class="sd">                    f&quot;Name {node.id} on line {node.lineno} of recipe not defined.&quot;)</span>
<span class="sd">            value = self._params.get(node.id)</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="s2">&quot;None&quot;</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Name </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2"> on line </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">lineno</span><span class="si">}</span><span class="s2"> of recipe not defined.&quot;</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="n">RecipeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Name </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2"> on line </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">lineno</span><span class="si">}</span><span class="s2"> of recipe not defined.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Name is loading </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2"> from </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">RecipeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;visit_Name: on recipe line </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">lineno</span><span class="si">}</span><span class="s2">, ctx is unexpected type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">ctx</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="KpfPipelineNodeVisitor.visit_For"><a class="viewcode-back" href="../../../api/pipeline/parse_ast.html#kpfpipe.pipelines.kpf_parse_ast.KpfPipelineNodeVisitor.visit_For">[docs]</a>    <span class="k">def</span> <span class="nf">visit_For</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implement the For node</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reset_visited_states</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_completed&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_started&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_params&#39;</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_params&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">iter</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">subnode</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">subnode</span><span class="p">)</span>
            <span class="k">return</span>
            
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_completed&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_started&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">storeQSizeBefore</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">awaiting_call_return</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">storeQSizeBefore</span><span class="p">:</span>
                    <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="n">params</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">target</span>             
                <span class="n">loadQSizeBefore</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">iter</span><span class="p">)</span>
                <span class="n">args</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
                <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">loadQSizeBefore</span><span class="p">:</span>
                    <span class="n">args</span><span class="o">.</span><span class="n">appendleft</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
                <span class="c1"># TODO: can this be made simpler?</span>
                <span class="n">args_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
                <span class="n">current_arg</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">args_iter</span><span class="p">)</span>
                <span class="n">params</span><span class="p">[</span><span class="s1">&#39;args_iter&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">args_iter</span>
                <span class="n">params</span><span class="p">[</span><span class="s1">&#39;current_arg&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_arg</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_params&#39;</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_started&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Starting For loop on recipe line </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">lineno</span><span class="si">}</span><span class="s2"> with arg </span><span class="si">{</span><span class="n">current_arg</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">params</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_params&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">assert</span><span class="p">(</span><span class="n">params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">target</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;target&#39;</span><span class="p">)</span>
                <span class="n">args_iter</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;args_iter&#39;</span><span class="p">)</span>
                <span class="n">current_arg</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;current_arg&#39;</span><span class="p">)</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_arg</span>
                <span class="k">for</span> <span class="n">subnode</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">subnode</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">awaiting_call_return</span><span class="p">:</span>
                        <span class="k">return</span>
                <span class="c1"># reset the node visited states for all nodes</span>
                <span class="c1"># underneath this &quot;for&quot; loop to set up for the</span>
                <span class="c1"># next iteration of the loop.</span>
                <span class="k">for</span> <span class="n">subnode</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">reset_visited_states</span><span class="p">(</span><span class="n">subnode</span><span class="p">)</span>
                <span class="c1"># iterate by updating current_arg (and the arg iterator)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">current_arg</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">args_iter</span><span class="p">)</span>
                    <span class="n">params</span><span class="p">[</span><span class="s1">&#39;current_arg&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_arg</span>
                <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Starting For loop on recipe line </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">lineno</span><span class="si">}</span><span class="s2"> with arg </span><span class="si">{</span><span class="n">current_arg</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_completed&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span></div>

    
<div class="viewcode-block" id="KpfPipelineNodeVisitor.visit_Assign"><a class="viewcode-back" href="../../../api/pipeline/parse_ast.html#kpfpipe.pipelines.kpf_parse_ast.KpfPipelineNodeVisitor.visit_Assign">[docs]</a>    <span class="k">def</span> <span class="nf">visit_Assign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assign one or more constant or calculated values to named variables</span>
<span class="sd">        The variable names come from the _store stack, while the values</span>
<span class="sd">        come from the _load stack.</span>
<span class="sd">        Calls to visit() may set self._awaiting_call_return, in which case</span>
<span class="sd">        we need to immediately return, and pick up where we left off later,</span>
<span class="sd">        completing the assignment.  This typically happens when there is</span>
<span class="sd">        a call to a processing primitive, which is queued up on the</span>
<span class="sd">        framework&#39;s event queue.  See also resume_recipe().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reset_visited_states</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_completed&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_completed_targets&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_completed_values&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_storeQSizeBefore&#39;</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_storeQSizeBefore&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_num_targets&#39;</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_num_targets&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">targets</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_completed&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">loadQSizeBefore</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="p">)</span>
            <span class="n">storeQSizeBefore</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_completed_targets&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_storeQSizeBefore&#39;</span><span class="p">,</span> <span class="n">storeQSizeBefore</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">targets</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">awaiting_call_return</span><span class="p">:</span>
                        <span class="k">return</span>
                <span class="n">num_store_targets</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="p">[</span><span class="n">storeQSizeBefore</span><span class="p">:])</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s2">&quot;kpf_num_targets&quot;</span><span class="p">,</span> <span class="n">num_store_targets</span><span class="p">)</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_completed_targets&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">num_store_targets</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_num_targets&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_completed_values&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">awaiting_call_return</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_completed_values&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="k">while</span> <span class="n">num_store_targets</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">loadQSizeBefore</span><span class="p">:</span>
                <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">num_store_targets</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Assign: </span><span class="si">{</span><span class="n">target</span><span class="si">}</span><span class="s2"> &lt;- </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">had_error</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">storeQSizeBefore</span><span class="p">:</span>
                <span class="n">had_error</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Assign: unfilled target: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span><span class="si">}</span><span class="s2"> on line </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">lineno</span><span class="si">}</span><span class="s2"> of recipe.&quot;</span><span class="p">)</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">loadQSizeBefore</span><span class="p">:</span>
                <span class="n">had_error</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Assign: unused value: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span><span class="si">}</span><span class="s2"> on line </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">lineno</span><span class="si">}</span><span class="s2"> of recipe.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">had_error</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">RecipeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Error during assignment on line </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">lineno</span><span class="si">}</span><span class="s2"> of recipe.  See log for details.&quot;</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_completed&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span></div>

    <span class="c1"># UnaryOp and the unary operators</span>
    
<div class="viewcode-block" id="KpfPipelineNodeVisitor.visit_UnaryOp"><a class="viewcode-back" href="../../../api/pipeline/parse_ast.html#kpfpipe.pipelines.kpf_parse_ast.KpfPipelineNodeVisitor.visit_UnaryOp">[docs]</a>    <span class="k">def</span> <span class="nf">visit_UnaryOp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        implement UnaryOp</span>
<span class="sd">        We don&#39;t support calls in unaryOp expressions, so we don&#39;t</span>
<span class="sd">        bother guarding for self.awaiting_call_return here, nor in</span>
<span class="sd">        the following Unary Operators</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reset_visited_states</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">operand</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;UnaryOp:&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">operand</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">)</span></div>

    <span class="c1"># Unary Operators</span>

    <span class="k">def</span> <span class="nf">_unary_op_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Helper function containing common implementation of unary operators. &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reset_visited_states</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">RecipeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unary operator </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> invoked on recipe line </span><span class="si">{</span><span class="n">name</span><span class="o">.</span><span class="n">lineno</span><span class="si">}</span><span class="s2"> with no argument&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="o">.</span><span class="n">pop</span><span class="p">()))</span>

<div class="viewcode-block" id="KpfPipelineNodeVisitor.visit_UAdd"><a class="viewcode-back" href="../../../api/pipeline/parse_ast.html#kpfpipe.pipelines.kpf_parse_ast.KpfPipelineNodeVisitor.visit_UAdd">[docs]</a>    <span class="k">def</span> <span class="nf">visit_UAdd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; implement UAdd &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unary_op_impl</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s2">&quot;UAdd&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="KpfPipelineNodeVisitor.visit_USub"><a class="viewcode-back" href="../../../api/pipeline/parse_ast.html#kpfpipe.pipelines.kpf_parse_ast.KpfPipelineNodeVisitor.visit_USub">[docs]</a>    <span class="k">def</span> <span class="nf">visit_USub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; implement USub &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unary_op_impl</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s2">&quot;USub&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="o">-</span><span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="KpfPipelineNodeVisitor.visit_UNot"><a class="viewcode-back" href="../../../api/pipeline/parse_ast.html#kpfpipe.pipelines.kpf_parse_ast.KpfPipelineNodeVisitor.visit_UNot">[docs]</a>    <span class="k">def</span> <span class="nf">visit_UNot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; implement UNot &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unary_op_impl</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s2">&quot;UNot&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="ow">not</span> <span class="n">x</span><span class="p">)</span></div>

    <span class="c1"># BinOp and the binary operators</span>

<div class="viewcode-block" id="KpfPipelineNodeVisitor.visit_BinOp"><a class="viewcode-back" href="../../../api/pipeline/parse_ast.html#kpfpipe.pipelines.kpf_parse_ast.KpfPipelineNodeVisitor.visit_BinOp">[docs]</a>    <span class="k">def</span> <span class="nf">visit_BinOp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        BinOp</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reset_visited_states</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;BinOp:&quot;</span><span class="p">)</span>
        <span class="c1"># right before left because they&#39;re being pushed on a stack, so left comes off first</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">)</span></div>

    <span class="c1"># binary operators</span>

    <span class="k">def</span> <span class="nf">_binary_op_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Helper function containing common implementation of binary operators. &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reset_visited_states</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">RecipeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Binary operator </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> invoked on recipe line </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">lineno</span><span class="si">}</span><span class="s2"> &quot;</span> <span class="o">+</span>
                <span class="sa">f</span><span class="s2">&quot;with insufficient number of arguments </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="o">.</span><span class="n">pop</span><span class="p">()))</span>

<div class="viewcode-block" id="KpfPipelineNodeVisitor.visit_Add"><a class="viewcode-back" href="../../../api/pipeline/parse_ast.html#kpfpipe.pipelines.kpf_parse_ast.KpfPipelineNodeVisitor.visit_Add">[docs]</a>    <span class="k">def</span> <span class="nf">visit_Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; implement the addition operator &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_binary_op_impl</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s2">&quot;Add&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="KpfPipelineNodeVisitor.visit_Sub"><a class="viewcode-back" href="../../../api/pipeline/parse_ast.html#kpfpipe.pipelines.kpf_parse_ast.KpfPipelineNodeVisitor.visit_Sub">[docs]</a>    <span class="k">def</span> <span class="nf">visit_Sub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; implement the subtraction operator &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_binary_op_impl</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s2">&quot;Sub&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="KpfPipelineNodeVisitor.visit_Mult"><a class="viewcode-back" href="../../../api/pipeline/parse_ast.html#kpfpipe.pipelines.kpf_parse_ast.KpfPipelineNodeVisitor.visit_Mult">[docs]</a>    <span class="k">def</span> <span class="nf">visit_Mult</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; implement the multiplication operator &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_binary_op_impl</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s2">&quot;Mult&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="KpfPipelineNodeVisitor.visit_Div"><a class="viewcode-back" href="../../../api/pipeline/parse_ast.html#kpfpipe.pipelines.kpf_parse_ast.KpfPipelineNodeVisitor.visit_Div">[docs]</a>    <span class="k">def</span> <span class="nf">visit_Div</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; implement the division operator &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_binary_op_impl</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s2">&quot;Div&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="p">)</span></div>
    
    <span class="c1"># Comparison operators</span>

    <span class="k">def</span> <span class="nf">_compare_op_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Helper function containing common implementation of comparison operators. &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reset_visited_states</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">RecipeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Comparison operator </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> invoked on line </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">lineno</span><span class="si">}</span><span class="s2"> &quot;</span> <span class="o">+</span>
                <span class="sa">f</span><span class="s2">&quot;with less than two arguments: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="o">.</span><span class="n">pop</span><span class="p">()))</span>

<div class="viewcode-block" id="KpfPipelineNodeVisitor.visit_Eq"><a class="viewcode-back" href="../../../api/pipeline/parse_ast.html#kpfpipe.pipelines.kpf_parse_ast.KpfPipelineNodeVisitor.visit_Eq">[docs]</a>    <span class="k">def</span> <span class="nf">visit_Eq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; implement Eq comparison operator &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comopare_op_impl</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s2">&quot;Eq&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="KpfPipelineNodeVisitor.visit_NotEq"><a class="viewcode-back" href="../../../api/pipeline/parse_ast.html#kpfpipe.pipelines.kpf_parse_ast.KpfPipelineNodeVisitor.visit_NotEq">[docs]</a>    <span class="k">def</span> <span class="nf">visit_NotEq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; implement NotEq comparison operator &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compare_op_impl</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s2">&quot;NotEq&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">y</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="KpfPipelineNodeVisitor.visit_Lt"><a class="viewcode-back" href="../../../api/pipeline/parse_ast.html#kpfpipe.pipelines.kpf_parse_ast.KpfPipelineNodeVisitor.visit_Lt">[docs]</a>    <span class="k">def</span> <span class="nf">visit_Lt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; implement Lt comparison operator &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compare_op_impl</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s2">&quot;Lt&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="KpfPipelineNodeVisitor.visit_LtE"><a class="viewcode-back" href="../../../api/pipeline/parse_ast.html#kpfpipe.pipelines.kpf_parse_ast.KpfPipelineNodeVisitor.visit_LtE">[docs]</a>    <span class="k">def</span> <span class="nf">visit_LtE</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; implement LtE comparison operator &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compare_op_impl</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s2">&quot;LtE&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="KpfPipelineNodeVisitor.visit_Gt"><a class="viewcode-back" href="../../../api/pipeline/parse_ast.html#kpfpipe.pipelines.kpf_parse_ast.KpfPipelineNodeVisitor.visit_Gt">[docs]</a>    <span class="k">def</span> <span class="nf">visit_Gt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; implement Gt comparison operator &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compare_op_impl</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s2">&quot;Gt&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="KpfPipelineNodeVisitor.visit_GtE"><a class="viewcode-back" href="../../../api/pipeline/parse_ast.html#kpfpipe.pipelines.kpf_parse_ast.KpfPipelineNodeVisitor.visit_GtE">[docs]</a>    <span class="k">def</span> <span class="nf">visit_GtE</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; implement GtE comparison operator &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compare_op_impl</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s2">&quot;GtE&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">y</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="KpfPipelineNodeVisitor.visit_Is"><a class="viewcode-back" href="../../../api/pipeline/parse_ast.html#kpfpipe.pipelines.kpf_parse_ast.KpfPipelineNodeVisitor.visit_Is">[docs]</a>    <span class="k">def</span> <span class="nf">visit_Is</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; implement Lt comparison operator &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compare_op_impl</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s2">&quot;Is&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="ow">is</span> <span class="n">y</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="KpfPipelineNodeVisitor.visit_IsNot"><a class="viewcode-back" href="../../../api/pipeline/parse_ast.html#kpfpipe.pipelines.kpf_parse_ast.KpfPipelineNodeVisitor.visit_IsNot">[docs]</a>    <span class="k">def</span> <span class="nf">visit_IsNot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; implement IsNot comparison operator &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compare_op_impl</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s2">&quot;IsNot&quot;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="ow">not</span> <span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="n">y</span><span class="p">))</span></div>
    
    <span class="c1"># TODO: implement visit_In and visit_NotIn.  Depends on support for Tuple and maybe others</span>

<div class="viewcode-block" id="KpfPipelineNodeVisitor.visit_Call"><a class="viewcode-back" href="../../../api/pipeline/parse_ast.html#kpfpipe.pipelines.kpf_parse_ast.KpfPipelineNodeVisitor.visit_Call">[docs]</a>    <span class="k">def</span> <span class="nf">visit_Call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implement function call</span>
<span class="sd">        The arguments are pulled from the _load stack into a deque.</span>
<span class="sd">        Targets are put on the _store stack.</span>
<span class="sd">        After the call has been pushed to the framework&#39;s event queue,</span>
<span class="sd">        we set our awaiting_call_return flag and return.  That flag</span>
<span class="sd">        causes immediate returns all the way up the call stack.</span>
<span class="sd">        When the primitive has been run by the framework, the next</span>
<span class="sd">        primitive will be our &quot;resume_recipe&quot;, which will set the</span>
<span class="sd">        returning_from_call flag and start traversing the AST tree</span>
<span class="sd">        from the top again.  Because of the various kpf_completed</span>
<span class="sd">        attributes set on nodes of the tree, processing will quickly</span>
<span class="sd">        get back to here, where the output of the primitive will be</span>
<span class="sd">        pushed on the _load stack, becoming the result of the call.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reset_visited_states</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_completed&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_completed&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">returning_from_call</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Call: </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2"> on recipe line </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">lineno</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="c1"># Build and queue up the called function and arguments</span>
                <span class="c1"># as a pipeline event.</span>
                <span class="c1"># The &quot;next_event&quot; item in the event_table, populated</span>
                <span class="c1"># by visit_ImportFrom, will ensure that the recipe</span>
                <span class="c1"># processing will continue by making resume_recipe</span>
                <span class="c1"># the next scheduled event primative.</span>
                <span class="c1"># add keyword arguments</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">kwnode</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">keywords</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">kwnode</span><span class="p">)</span>
                    <span class="n">tup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">event_args</span> <span class="o">=</span> <span class="n">Arguments</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">id</span><span class="o">+</span><span class="s2">&quot;_args&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="c1"># add positional arguments</span>
                <span class="k">for</span> <span class="n">argnode</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">argnode</span><span class="p">)</span>
                    <span class="n">event_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">push_event</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">event_args</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Queued </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2"> with args </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">event_args</span><span class="p">)</span><span class="si">}</span><span class="s2">; awaiting return.&quot;</span><span class="p">)</span>
                <span class="c1">#</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">awaiting_call_return</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># returning from a call (pipeline event):</span>
                <span class="c1"># Get any returned values, stored by resume_recipe() in self.call_output,</span>
                <span class="c1"># and push them on the _load stack for Assign (or whatever) to handle.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Call on recipe line </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">lineno</span><span class="si">}</span><span class="s2"> returned output </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">call_output</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">call_output</span><span class="p">,</span> <span class="n">Arguments</span><span class="p">):</span>
                    <span class="c1"># got output that we can deal with, otherwise, ignore the returned value</span>
                    <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">call_output</span><span class="p">)):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">call_output</span><span class="p">[</span><span class="n">ix</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">call_output</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">returning_from_call</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_completed&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="KpfPipelineNodeVisitor.visit_keyword"><a class="viewcode-back" href="../../../api/pipeline/parse_ast.html#kpfpipe.pipelines.kpf_parse_ast.KpfPipelineNodeVisitor.visit_keyword">[docs]</a>    <span class="k">def</span> <span class="nf">visit_keyword</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        implement keyword as follows:</span>
<span class="sd">        Since this only occurs in the context of keyword arguments in a</span>
<span class="sd">        call signature, we can generate tuples of (keyword, value)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reset_visited_states</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="c1"># let the value node put the value on the _load stack</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;keyword: </span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span></div>

<div class="viewcode-block" id="KpfPipelineNodeVisitor.visit_Compare"><a class="viewcode-back" href="../../../api/pipeline/parse_ast.html#kpfpipe.pipelines.kpf_parse_ast.KpfPipelineNodeVisitor.visit_Compare">[docs]</a>    <span class="k">def</span> <span class="nf">visit_Compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implement Compare as follows:</span>
<span class="sd">        visiting &quot;left&quot; and &quot;comparators&quot; puts values on the _load stack.</span>
<span class="sd">        visiting &quot;ops&quot; evaluates some comparison operator, and puts the result</span>
<span class="sd">        on the _load stack as a Bool.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reset_visited_states</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_completed&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">comparators</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">ops</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_completed&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Compare&quot;</span><span class="p">)</span>
            <span class="n">loadQSizeBefore</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="p">)</span>
            <span class="c1"># comparators before left because they&#39;re going on a stack, so left can be pulled first</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">comparators</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">ops</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_completed&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="KpfPipelineNodeVisitor.visit_If"><a class="viewcode-back" href="../../../api/pipeline/parse_ast.html#kpfpipe.pipelines.kpf_parse_ast.KpfPipelineNodeVisitor.visit_If">[docs]</a>    <span class="k">def</span> <span class="nf">visit_If</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implementation of If</span>
<span class="sd">        Evaluate the test and visit one of the two branches, body or orelse.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reset_visited_states</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_completed&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_completed_test&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_boolResult&#39;</span><span class="p">):</span>
                <span class="nb">delattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_boolResult&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">test</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">orelse</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_completed&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_completed_test&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="n">loadQSizeBefore</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">test</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">loadQSizeBefore</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">RecipeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;visit_If: on recipe line </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">lineno</span><span class="si">}</span><span class="s2">, test didn&#39;t push a result on the _load stack&quot;</span><span class="p">)</span>
                <span class="n">boolResult</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;If condition on recipe line </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">lineno</span><span class="si">}</span><span class="s2"> was </span><span class="si">{</span><span class="n">boolResult</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_boolResult&#39;</span><span class="p">,</span> <span class="n">boolResult</span><span class="p">)</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_completed_test&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">boolResult</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_boolResult&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">boolResult</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;If on recipe line </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">lineno</span><span class="si">}</span><span class="s2"> pushing and visiting Ifso&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">awaiting_call_return</span><span class="p">:</span>
                        <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;If on recipe line </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">lineno</span><span class="si">}</span><span class="s2"> pushing and visiting Else&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">orelse</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">awaiting_call_return</span><span class="p">:</span>
                        <span class="k">return</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_completed&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="KpfPipelineNodeVisitor.visit_List"><a class="viewcode-back" href="../../../api/pipeline/parse_ast.html#kpfpipe.pipelines.kpf_parse_ast.KpfPipelineNodeVisitor.visit_List">[docs]</a>    <span class="k">def</span> <span class="nf">visit_List</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        List node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reset_visited_states</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_completed&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">elts</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;List&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s2">&quot;kpf_completed&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">elts</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s2">&quot;kpf_completed&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="KpfPipelineNodeVisitor.visit_Tuple"><a class="viewcode-back" href="../../../api/pipeline/parse_ast.html#kpfpipe.pipelines.kpf_parse_ast.KpfPipelineNodeVisitor.visit_Tuple">[docs]</a>    <span class="k">def</span> <span class="nf">visit_Tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tuple node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reset_visited_states</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_completed&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Tuple&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s2">&quot;kpf_completed&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">elts</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s2">&quot;kpf_completed&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="KpfPipelineNodeVisitor.visit_NameConstant"><a class="viewcode-back" href="../../../api/pipeline/parse_ast.html#kpfpipe.pipelines.kpf_parse_ast.KpfPipelineNodeVisitor.visit_NameConstant">[docs]</a>    <span class="k">def</span> <span class="nf">visit_NameConstant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        NameConstant</span>
<span class="sd">        implement name constant by putting on the _load stack</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reset_visited_states</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;NameConstant: </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1">#ctx of NameConstant is always Load</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="KpfPipelineNodeVisitor.visit_Num"><a class="viewcode-back" href="../../../api/pipeline/parse_ast.html#kpfpipe.pipelines.kpf_parse_ast.KpfPipelineNodeVisitor.visit_Num">[docs]</a>    <span class="k">def</span> <span class="nf">visit_Num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Num</span>
<span class="sd">        implement numeric constant by putting it on the _load stack</span>

<span class="sd">        NB: An instance of Num can appear as different nodes in the same AST,</span>
<span class="sd">        so we can&#39;t store node specific information as an attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reset_visited_states</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Num: </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># ctx of Num is always Load</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">n</span><span class="p">)</span></div>

<div class="viewcode-block" id="KpfPipelineNodeVisitor.visit_Str"><a class="viewcode-back" href="../../../api/pipeline/parse_ast.html#kpfpipe.pipelines.kpf_parse_ast.KpfPipelineNodeVisitor.visit_Str">[docs]</a>    <span class="k">def</span> <span class="nf">visit_Str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Str node</span>
<span class="sd">        TODO: I&#39;m not sure what to do with a multiline comment expressed as Str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reset_visited_states</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Str: </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">s</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># ctx of Str is always Load</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">s</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="KpfPipelineNodeVisitor.visit_Expr"><a class="viewcode-back" href="../../../api/pipeline/parse_ast.html#kpfpipe.pipelines.kpf_parse_ast.KpfPipelineNodeVisitor.visit_Expr">[docs]</a>    <span class="k">def</span> <span class="nf">visit_Expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Expr node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reset_visited_states</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_completed&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_completed&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">awaiting_call_return</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;kpf_complted&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="KpfPipelineNodeVisitor.generic_visit"><a class="viewcode-back" href="../../../api/pipeline/parse_ast.html#kpfpipe.pipelines.kpf_parse_ast.KpfPipelineNodeVisitor.generic_visit">[docs]</a>    <span class="k">def</span> <span class="nf">generic_visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Called if no explicit visitor function exists for a node.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;generic_visit: got unsupported node </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="n">RecipeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Unsupported language feature: </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="KpfPipelineNodeVisitor.reset_visited_states"><a class="viewcode-back" href="../../../api/pipeline/parse_ast.html#kpfpipe.pipelines.kpf_parse_ast.KpfPipelineNodeVisitor.reset_visited_states">[docs]</a>    <span class="k">def</span> <span class="nf">reset_visited_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resets kpf_completed and other attributes of this and all subnodes,</span>
<span class="sd">        e.g. so that a for loop can iterate with a fresh start.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_visited_states</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">awaiting_call_return</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">returning_from_call</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">call_output</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_store</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_visited_states</span> <span class="o">=</span> <span class="kc">False</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Arpita Roy, BJ Fulton, Andrew Howard

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>